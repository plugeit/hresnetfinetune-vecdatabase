# -*- coding: utf-8 -*-
"""compare18_34_50.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hpD55G8zk838CtlJC0zKr45Rj9Vw1QBU
"""

!wget -O part-000002.zip 'https://storage.googleapis.com/kaggle-data-sets/5862440/9608141/compressed/data.zip?X-Goog-Algorithm=GOOG4-RSA-SHA256&X-Goog-Credential=gcp-kaggle-com%40kaggle-161607.iam.gserviceaccount.com%2F20241013%2Fauto%2Fstorage%2Fgoog4_request&X-Goog-Date=20241013T043423Z&X-Goog-Expires=259200&X-Goog-SignedHeaders=host&X-Goog-Signature=4d48acfce1ef0e8ed4e7dbd865b86f3a426d7ec62157a610024081ab5cc0aaa4ec24f041f520cb7dc6f1a1386fe0eb3d0de563c827a3bccf300e0815753f20d0288bdd0abd5a28508928a968c02969219597bef048af928ea5aa727a0d4e8f671c4677427d143e22b868719dd7241996accf5a91a66366d8685da53efe18db564a657801fca29a308340ca34ea4342c901e96544691757fd09f2a7b3075890435a43908b6f6160a3f543de663247c9a7cf426a6689e7aa76d472409982c96bfbc5f03784dc3ca3e2154f49049ccaf1ca2aa17e4af513bb0d23e21a5bb7f1d2ec1f519f21baa5477328fcdb3dd45b20ad6cd9256dd08811073c64440f3e55aa4e'

!unzip part-000002.zip

import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from torchvision import datasets, transforms
from torchvision import models
import matplotlib.pyplot as plt

# Define transformations for the test dataset (same as training)
_transform = transforms.Compose([
    transforms.Resize((244, 244)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# Load the test dataset
test_dataset = datasets.ImageFolder(root='val', transform=_transform)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

# Load the trained models (assuming they are saved as .pth files)
device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')

# Load each model (assuming they are saved as ai_vs_nonai_resnet18.pth, etc.)
models = {
    "ResNet-18": torch.load('ai_vs_nonai_model_18.pth', map_location=device),
    "ResNet-34": torch.load('ai_vs_nonai_model_34.pth', map_location=device),
    "ResNet-50": torch.load('ai_vs_nonai_model_50.pth', map_location=device),
}

# Set all models to evaluation mode
for model in models.values():
    model.to(device)
    model.eval()

# Define the loss function (same as during training)
criterion = nn.CrossEntropyLoss()

# Function to evaluate a model on the test dataset
def evaluate_model(model, dataloader, device):
    test_loss = 0.0
    correct = 0
    total = 0

    with torch.no_grad():
        for images, labels in dataloader:
            images, labels = images.to(device), labels.to(device)

            # Forward pass
            outputs = model(images)
            loss = criterion(outputs, labels)
            test_loss += loss.item()

            # Get predictions
            _, predicted = torch.max(outputs, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

    # Calculate loss and accuracy
    avg_loss = test_loss / len(dataloader)
    accuracy = 100 * correct / total

    return avg_loss, accuracy

# Evaluate each model and store results
results = {}
for model_name, model in models.items():
    loss, accuracy = evaluate_model(model, test_loader, device)
    results[model_name] = {"loss": loss, "accuracy": accuracy}

# Extract data for plotting
model_names = list(results.keys())
losses = [results[model]["loss"] for model in model_names]
accuracies = [results[model]["accuracy"] for model in model_names]

# Create subplots for loss and accuracy
fig, ax = plt.subplots(1, 2, figsize=(12, 5))

# Plot Losses
ax[0].bar(model_names, losses, color='skyblue')
ax[0].set_title('Test Loss Comparison')
ax[0].set_xlabel('Model')
ax[0].set_ylabel('Loss')
ax[0].set_xticks(range(len(model_names)))
ax[0].set_xticklabels(model_names)

# Plot Accuracies
ax[1].bar(model_names, accuracies, color='lightgreen')
ax[1].set_title('Test Accuracy Comparison')
ax[1].set_xlabel('Model')
ax[1].set_ylabel('Accuracy (%)')
ax[1].set_xticks(range(len(model_names)))
ax[1].set_xticklabels(model_names)

# Display the plots
plt.tight_layout()
plt.show()

print(losses)
print(accuracies)